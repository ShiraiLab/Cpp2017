/*
応用プログラミングA 第10回演習 関数オーバーロード
問題1(必須) オブジェクト作成と対応するコンストラクタの確認
*/

#include <iostream>
using namespace std;

class myclass {
	int x;
public:
	myclass() {
		x = 0;
		cout << "初期化なしのコンストラクタ\n";
	}
	myclass(int n) {
		x = n;
		cout << "初期化ありのコンストラクタ\n";
	}
	int getx() { return x; }
};

int main() {
	//コンストラクタに引数を渡して初期化
	myclass o1(0); //出題側の実行結果を見る限りでは「初期化あり」であるべき
	cout << "o1: " << o1.getx() << "\n";
	//コンストラクタには引数なしのコンストラクタを使って初期化
	myclass o2; //必要に応じて修正
	cout << "o2: " << o1.getx() << "\n";
	//オブジェクトを配列で初期化
	myclass o3[2]; //実行結果をみるに２つの箱を持った配列として宣言すべき
	cout << "o3[0]: " << o3[0].getx() << "\n";
	cout << "o3[1]: " << o3[0].getx() << "\n";
	//オブジェクトを配列で初期化する際に，大かっこをつかって，値を指定する例
	myclass o4[2] = { 0, 0 }; //この書式は覚えるしかないですね，発想しようがない．
	cout << "o4[0]: " << o4[0].getx() << "\n";
	cout << "o4[1]: " << o4[0].getx() << "\n";
	// newを使って配列オブジェクトを作る際に，
	// 最初の宣言で *(アスタリスク)を付け忘れる例
	myclass *o5;
	o5 = new myclass[2]; //これは配列として初期化している，にもかかわらず o5 はポインタではない！
	if (!o5) {
		cout << "メモリ割り当てエラー\n";
		return 1;
	}
	cout << "o5[0]" << o5[0].getx() << "\n";
	cout << "o5[1]" << o5[1].getx() << "\n";
	return 0;
}